# Research Methods

# I spent [] hours on this challenge.

i_want_pets = ["I", "want", 3, "pets", "but", "only", "have", 2]
my_family_pets_ages = {"Evi" => 6, "Ditto" => 3, "Hoobie" => 3, "George" => 12, "Bogart" => 4, "Poly" => 4, "Annabelle" => 0}

# Person 1's solution
def my_array_finding_method(source, thing_to_find)
  source.select {|word| word.to_s.include?(thing_to_find)}
end

def my_hash_finding_method(source, thing_to_find)
source.select {|k,v| v==thing_to_find}.values
end

# Identify and describe the Ruby method(s) you implemented.
# .select
## Returns an array containing all elements of an enumerator for which the given block returns a true value.
# .to_s
## Returns a string representation of what is called.
# .inlude?()
## Checks whether a particular item is included in the array.


# Person 2
def my_array_modification_method!(source, thing_to_modify)
  source.map!  do |e|
    if e.class == Fixnum
      e = e + thing_to_modify
    elsif e.class == String
      e = e
    end
  end
  return source
end

def my_hash_modification_method!(source, thing_to_modify)
  source.keys.each do |k|
    source[k] += thing_to_modify
  end
  return source
end

# Identify and describe the Ruby method(s) you implemented.
# .map! ---> changes array in place (destructively)
# .keys.each ---> enumerates through the keys in the hash


# Person 3
def my_array_sorting_method(source)
  newarr = Array.new(source)
  newarr.sort_by {|x| x.to_s}
end

def my_hash_sorting_method(source)
  hash = source.clone
  hash.sort_by {|k, v| v}
end
# Identify and describe the Ruby method(s) you implemented.
#sort_by : "Sorts enum using a set of keys generated by mapping the values in enum through the given block - sort_by { |obj| block } â†’ array"

# Person 4
def my_array_deletion_method!(source, thing_to_delete)
  source.reject! { |element| element.to_s.include? thing_to_delete}
end

# p my_array_deletion_method!(i_want_pets, "a")

def my_hash_deletion_method!(source, thing_to_delete)
  source.delete(thing_to_delete)
  source
end

# p my_hash_deletion_method!(my_family_pets_ages, "George")

=begin
# Identify and describe the Ruby method(s) you implemented.
# .reject!
# .include?
# .delete
Explanation
  First Method - I used .reject!, .to_s, and .include?, and .delete in the method. I used .to_s to convert each element of the array to a string, and .include? to determine if the "thing_to_delete" was a substring of each element (that was converted to a string) in the array. If "thing_to_delete" was a substring of the element, then I used .reject! to remove it from the array.
  Second Method - I used .delete in the method. When you execute .delete, it will search the hash automatically for the "thing_to_delete."
  A trick I learned for searching through the Ruby Docs is to look at the list on the left of the screen and just scan for a method that you think might work. Then navigate right to it and look at the code examples.
=end

# Person 5
def my_array_splitting_method(source)
  split_array = [source.find_all {|x| x.is_a?(Integer)}, source.find_all {|x| x.is_a?(Integer) == false}]
end

def my_hash_splitting_method(source, age)
  split_hash_array = [source.select{|k,v| v <= age}.to_a, source.select{|k,v| v > age}.to_a]
end

# Identify and describe the Ruby method(s) you implemented.
#For the array splitting method, I implemented two methods: .find_all and .is_a? .find_all grabs all elements in an array that meet the condition provided in the code block, and puts them into a new array. Here, I have two code blocks, one for the first array and one for the second, and they're mirro images of each other. The code block for the first .find_all is |x| x.is_a?(Integer). .is_a?(ObjectType) returns true if the object on which it's called is of the type specified. Here, it returned true if the element was an Integer. Thus, the .select method grabbed all the elements in source that were of object type Integer and put it into a new array. The second code block did the same thing, except it grabbed all elements that were NOT Integers and put them in a second array. Those two arrays were both returned by being put into the split_array, as follows: split_array = [codeblock1, codeblock2].

#For the hash splitting method, I used two methods: the .select method and the .to_a method. The .select method works much like .find_all, except it's for hashes instead of arrays. It grabs all the elements satisfying the condition in the code block and puts them in a new hash. Here, the conditions for the two new hashes were |k,v| v <= age and v > age, respectively. That checked if the value of each hash pair was less than or equal to the age parameter. The .select method returns hashes, however, so I used the .to_a method, which just turns hashes into arrays, in the following format: {k1 => v1, k2 => v2} becomes [[k1, v1], [k2, v2]]. Fortunately that's the structure the method is supposed to return.


# Release 1: Identify and describe the Ruby method you implemented. Teach your
# accountability group how to use the methods.
#See immediately above.
#


# Release 3: Reflect!
# What did you learn about researching and explaining your research to others?
#I learned that, at least for me, the easiest way to use the Ruby Docs is to think of what I want a method to do, then go through the sidebar that lists all the methods for a class and look for words that are similar to what I'm trying to do. That's how I found .find_all and .is_a?.
#
#I find that trying to explain my code to others is very similar to the reflection's I've been doing--I'm assuming others have about the same level of understanding as I do. This might work for now, when everyone I'm talking to has about the same level of exposure (and it's a pretty low level), but I should be careful when I have a higher degree of specialization, and make sure I can still break it down for a beginner.




